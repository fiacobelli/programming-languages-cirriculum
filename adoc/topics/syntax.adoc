= Syntax
Source: Chapter 3.1 - 3.3 ^xref:sources[4]^

== Structure of a programming language
* the form of its expressions, statements, and program units
* A language is composed of strings of chars from some alphabet
* Each string of chars is called a _sentence_ or _statement_.
* The syntax defines a set of rules that stipulate which strings of chars from the alphabet are valid statements.


== Lexemes
* Lexemes are small units of syntax.
* Lexemes can be broken down and further specified.
* Usually, language-level syntax rules use lexemes as units.
* Rules specifying valid lexemes are handled separately as lexical descriptions of the language.

=== Example Lexemes
* numeric literals
* operators
* special words

=== Lexemes Groupings
* Lexemes are divided into groups and given names called _tokens_.


=== Example Token: Identifiers
This includes all names of vars, methods and classes.

* `var x = 10`
* `public class MyClass {...}`
* `int squareRoot(int number){...}`
* `(define factorial (...))`

=== Example Token: Numeric Literals
This includes raw number values.

* `var x = 10`
* `squareRoot(25)`
* (factorial 5)


=== Example Token: Operations
This is a grouping of tokens that only include one value related to a math operation.

* _equal_sign_: `var x = 10`
* _plus_op_ : `var x = 10 + 5`
* _minus_op_: `(- 2 1)`


=== Example Token: Reserved Words
These include a set of words that are reserved for specific operations.

* `if (x = 1){...}`
* `while (x<10){...}`
* `public class MyClass {...}`
* `(define factorial (...))`


=== Breakdown of a Statement
[source,java]
----
index = 2 * count + 17;
----

* identifiers
* equal_sign
* int_literal
* mult_op
* plus_op
* semicolon

== Formally defining languages

* Recognition
* Generation
* Neither is practical for end-users of the language

=== Recognizers
* Determines if a set of strings are valid syntax for the language.
** Syntax analysis.
* Given language `L` with alphabet `S`, you could create a recognizer `R`.
* `R` can determine if any string using `S` is in `L`.
* Recognizers operate like filters.
** Since `L` is likely infinite, it would be impossible for `R` to check all possible strings using `S`.

=== Generators
* Generates statements (strings) that are valid for a language.
* ????

=== Grammar
* formal language generation mechanism
* used to describe the syntax of a language
* Two grammar classes: _regular_ and _context-free_.
** Used for describing just the tokens of a language
** Used for describing the language as a whole, using tokens.

=== BNF/Grammar
* A _Backus-Naur Form_ or _BNF_ description or grammar is a set of rules that describe a language.
** Grammar and _BNF_ description are interchangeable

=== Parts of a Rule
* _LHS_ -> _RHS_
* The _LHS_ contains the _abstraction_ being defined.
* The _RHS_ contains the actual definition, which can contain more _abstractions_ as well as _tokens_.
* Abstractions are called _non-terminals_.
* Tokens are called _terminals_.
* Terminals and non-terminals are known as _symbols_

=== Example Rule
* `<assign> -> <var> = <expression>`
* non-terminals
* terminals

=== Multiple Definitions
* Any non-terminal can have multiple definitions.
+
[source]
----
<if_stmt> -> if ( <logic_expr> ) <stmt>
<if_stmt> -> if ( <logic_expr> ) <stmt> else <stmt>
----

=== Multiple Definitions in One Rule
* Multiple definitions can exist in a single rule.
+
[source]
----
<if_stmt> -> if ( <logic_expr> ) <stmt>
           | if ( <logic_expr> ) <stmt> else <stmt>
----

=== Rules Describing Lists
* If you want to define a rule that allows for a list of variable size, you need to use recursion.
+
[source]
----
<ident_list> -> identifier
              | identifier, <ident_list>
----

=== Start Symbol
* Special non-terminal that represents a complete program.
* A program is generated by successfully applying the rules of the grammar to the start symbol.
** This process is called a _derivation_

=== Example Derivation: Grammar _G_

[source]
----
<program>    -> begin <stmt_list> end
<stmt_list>  -> <stmt>
              | <stmt> ; <stmt_list>
<stmt>       -> <var> = <expression>
<var>        -> A|B|C
<expression> -> <var> + <var>
              | <var> â€“ <var>
              | <var>
----

* start symbol
* non-terminals
* terminals

=== Example Derivation: Program _P_

[source]
----
<program> => begin <stmt_list> end
----


=== Example Derivation: Derivation of _P_

[source]
----
<program> => begin <stmt_list> end
          => begin <stmt>;<stmt_list>end
          => begin <var> = <expression>;<stmt_list>end
          => begin A = <expression> ; <stmt_list> end
          => begin A = <var> + <var> ; <stmt_list> end
          => begin A = B + <var> ; <stmt_list> end
          => begin A = B + C ; <stmt_list> end
          => begin A = B + C ;<stmt>end
          => begin A = B + C ; <var> = <expression> end
          => begin A = B + C ; B = <expression> end
          => begin A = B + C ; B = <var> end
          => begin A = B + C ; B = C end
----

* Sentential forms
* Replace until no non-terminals.
* Last sentential form with no non-terminals is the generated sentence.

=== Leftmost vs. Rightmost Derivations
* Derivations can perform their substitutions either left-first or right-first
* Substitute left-most or right-most non-terminal until there are only terminals.
* _P_ used left-most
* Order has no impact on the generated language.

=== Parse Trees
* Derivations can be represented by a tree
* internal nodes are non-terminals.
* leaves are terminals

=== Example parse tree
insert diagram

=== Ambiguous Grammars
* If a grammar can produce 2 or more parse trees for a give derivation, it is ambiguous

=== Example Ambiguous Grammar: Grammar _AG_

[source]
----
<assign> -> <id> = <expr>
<id>     -> A|B|C
<expr>   -> <expr> + <expr>
          | <expr> * <expr>
          | ( <expr> )
          | <id>
----

* How is _AG_ different from _G_?

=== Example Ambiguous Grammar: Program _AP_ and Derivation

[source]
----
<assign> => <id> = <expr>
         => A = <expr>
         => A = <id> * <expr>
         => A = B * <expr>
         => A = B * ( <expr> )
         => A = B * ( <id> + <expr> )
         => A = B * ( A + <expr> )
         => A = B * ( A + <id> )
         => A = B * ( A + C )
----

=== Example Ambiguous Grammar: Parse Tree
insert diagram

=== Example Ambiguous Grammar: Another Parse Tree
insert diagram

=== Example Ambiguous Grammar: Problem?
* Why is this an issue?
** order of operations


=== Example Unambiguous Grammar: Grammar _UG_

[source]
----
<assign> -> <id> = <expr>
<id>     -> A|B|C
<expr>   -> <expr> + <term>
          | <term>
<term>   -> <term> * <factor>
          | <factor>
<factor> -> ( <expr> )
          | <id>
----


=== Example Unambiguous Grammar: Program _UP_ and Derivation
[source]
----
<assign> => <id> = <expr>
         => A = <expr>
         => A = <expr> + <term>
         => A = <term> + <term>
         => A = <factor> + <term>
         => A = <id> + <term>
         => A = B + <term>
         => A = B + <term> * <factor>
         => A = B + <factor> * <factor>
         => A = B + <id> * <factor>
         => A = B + C * <factor>
         => A = B + C * <id>
         => A = B + C * A
----

=== Example Unambiguous Grammar: Parse Tree
insert diagram

=== Operator Associativity
* When two operators have the same precedence
* Example `5 + 4 - 3`

=== Extended BNF
* Helps with readability, but does not change descriptive power

=== EBNF Example: if-else
.BNF
[source]
----
<if_stmt> -> if (<expression>) <statement>
           | if (<expression>) <statement> else <statement>
----

=== Exercise 1
Using Grammar _G_:

[source]
----
<program> => begin <stmt_list> end
          (Fill this in)
          => begin B = C ; A = B + C end
----

=== Exercise 2
Using Grammar _G_:

[source]
----
<program> => begin <stmt_list> end
          (Fill this in)
          => begin  A = B + C - D ; B = C + E end
----

=== Exercise 3

[source]
----
<program> => begin <stmt_list> end
          (Fill this in)
          => begin A = D - 5; B = B + C - A + D; end
----


== Homework
* Read chapter 3.1 - 3.3
