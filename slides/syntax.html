<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="author" content="Source: Chapter 3.1 - 3.4 ^link:https://github.com/rhoads-zach/programming-languages-cirriculum/blob/master/adoc/topics/sources.adoc[4]^"><title>Syntax</title><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui" name="viewport"><link href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.6.0/css/reveal.css" rel="stylesheet"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.6.0/css/theme/black.css" id="theme"><link href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.6.0/lib/css/zenburn.css" rel="stylesheet"><script>var link = document.createElement( 'link' );
link.rel = 'stylesheet';
link.type = 'text/css';
link.href = window.location.search.match( /print-pdf/gi ) ? "https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.6.0/css/print/pdf.css" : "https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.6.0/css/print/paper.css";
document.getElementsByTagName( 'head' )[0].appendChild( link );</script><!--[if lt IE 9]><script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.6.0/lib/js/html5shiv.js"></script><![endif]--></head><body><div class="reveal"><div class="slides"><section class="title" data-state="title"><h1>Syntax</h1><p class="author"><small>Source: Chapter 3.1 - 3.4 ^link:https://github.com/rhoads-zach/programming-languages-cirriculum/blob/master/adoc/topics/sources.adoc[4]^</small></p></section><section id="structure_of_a_programming_language"><h2>Structure of a programming language</h2><div class="ulist"><ul><li><p>the form of its expressions, statements, and program units</p></li><li><p>A language is composed of strings of chars from some alphabet</p></li><li><p>Each string of chars is called a <em>sentence</em> or <em>statement</em>.</p></li><li><p>The syntax defines a set of rules that stipulate which strings of chars from the alphabet are valid statements.</p></li></ul></div></section>
<section><section id="lexemes"><h2>Lexemes</h2><div class="ulist"><ul><li><p>Lexemes are small units of syntax.</p></li><li><p>Lexemes can be broken down and further specified.</p></li><li><p>Usually, language-level syntax rules use lexemes as units.</p></li><li><p>Rules specifying valid lexemes are handled separately as lexical descriptions of the language.</p></li></ul></div></section><section id="example_lexemes"><h2>Example Lexemes</h2><div class="ulist"><ul><li><p>numeric literals</p></li><li><p>operators</p></li><li><p>special words</p></li></ul></div></section><section id="lexemes_groupings"><h2>Lexemes Groupings</h2><div class="ulist"><ul><li><p>Lexemes are divided into groups and given names called <em>tokens</em>.</p></li></ul></div></section><section id="example_token_identifiers"><h2>Example Token: Identifiers</h2><div class="paragraph"><p>This includes all names of vars, methods and classes.</p></div>
<div class="ulist"><ul><li><p><code>var x = 10</code></p></li><li><p><code>public class MyClass {&#8230;&#8203;}</code></p></li><li><p><code>int squareRoot(int number){&#8230;&#8203;}</code></p></li><li><p><code>(define factorial (&#8230;&#8203;))</code></p></li></ul></div></section><section id="example_token_numeric_literals"><h2>Example Token: Numeric Literals</h2><div class="paragraph"><p>This includes raw number values.</p></div>
<div class="ulist"><ul><li><p><code>var x = 10</code></p></li><li><p><code>squareRoot(25)</code></p></li><li><p>(factorial 5)</p></li></ul></div></section><section id="example_token_operations"><h2>Example Token: Operations</h2><div class="paragraph"><p>This is a grouping of tokens that only include one value related to a math operation.</p></div>
<div class="ulist"><ul><li><p><em>equal_sign</em>: <code>var x = 10</code></p></li><li><p><em>plus_op</em> : <code>var x = 10 + 5</code></p></li><li><p><em>minus_op</em>: <code>(- 2 1)</code></p></li></ul></div></section><section id="example_token_reserved_words"><h2>Example Token: Reserved Words</h2><div class="paragraph"><p>These include a set of words that are reserved for specific operations.</p></div>
<div class="ulist"><ul><li><p><code>if (x = 1){&#8230;&#8203;}</code></p></li><li><p><code>while (x&lt;10){&#8230;&#8203;}</code></p></li><li><p><code>public class MyClass {&#8230;&#8203;}</code></p></li><li><p><code>(define factorial (&#8230;&#8203;))</code></p></li></ul></div></section><section id="breakdown_of_a_statement"><h2>Breakdown of a Statement</h2><div class="listingblock"><div class="content"><pre class="highlight"><code class="java language-java">index = 2 * count + 17;</code></pre></div></div>
<div class="ulist"><ul><li><p>identifiers</p></li><li><p>equal_sign</p></li><li><p>int_literal</p></li><li><p>mult_op</p></li><li><p>plus_op</p></li><li><p>semicolon</p></li></ul></div></section></section>
<section><section id="formally_defining_languages"><h2>Formally defining languages</h2><div class="ulist"><ul><li><p>Recognition</p></li><li><p>Generation</p></li><li><p>Neither is practical for end-users of the language</p></li></ul></div></section><section id="recognizers"><h2>Recognizers</h2><div class="ulist"><ul><li><p>Determines if a set of strings are valid syntax for the language.</p><div class="ulist"><ul><li><p>Syntax analysis.</p></li></ul></div></li><li><p>Given language <code>L</code> with alphabet <code>S</code>, you could create a recognizer <code>R</code>.</p></li><li><p><code>R</code> can determine if any string using <code>S</code> is in <code>L</code>.</p></li><li><p>Recognizers operate like filters.</p><div class="ulist"><ul><li><p>Since <code>L</code> is likely infinite, it would be impossible for <code>R</code> to check all possible strings using <code>S</code>.</p></li></ul></div></li></ul></div></section><section id="generators"><h2>Generators</h2><div class="ulist"><ul><li><p>Generates statements (strings) that are valid for a language.</p></li><li><p>????</p></li></ul></div></section><section id="grammar"><h2>Grammar</h2><div class="ulist"><ul><li><p>formal language generation mechanism</p></li><li><p>used to describe the syntax of a language</p></li><li><p>Two grammar classes: <em>regular</em> and <em>context-free</em>.</p><div class="ulist"><ul><li><p>Used for describing just the tokens of a language</p></li><li><p>Used for describing the language as a whole, using tokens.</p></li></ul></div></li></ul></div></section><section id="bnf_grammar"><h2>BNF/Grammar</h2><div class="ulist"><ul><li><p>A <em>Backus-Naur Form</em> or <em>BNF</em> description or grammar is a set of rules that describe a language.</p><div class="ulist"><ul><li><p>Grammar and <em>BNF</em> description are interchangeable</p></li></ul></div></li></ul></div></section><section id="parts_of_a_rule"><h2>Parts of a Rule</h2><div class="ulist"><ul><li><p><em>LHS</em> &#8594; <em>RHS</em></p></li><li><p>The <em>LHS</em> contains the <em>abstraction</em> being defined.</p></li><li><p>The <em>RHS</em> contains the actual definition, which can contain more <em>abstractions</em> as well as <em>tokens</em>.</p></li><li><p>Abstractions are called <em>non-terminals</em>.</p></li><li><p>Tokens are called <em>terminals</em>.</p></li><li><p>Terminals and non-terminals are known as <em>symbols</em></p></li></ul></div></section><section id="example_rule"><h2>Example Rule</h2><div class="ulist"><ul><li><p><code>&lt;assign&gt; &#8594; &lt;var&gt; = &lt;expression&gt;</code></p></li><li><p>non-terminals</p></li><li><p>terminals</p></li></ul></div></section><section id="multiple_definitions"><h2>Multiple Definitions</h2><div class="ulist"><ul><li><p>Any non-terminal can have multiple definitions.</p><div class="listingblock"><div class="content"><pre class="highlight"><code>&lt;if_stmt&gt; -&gt; if ( &lt;logic_expr&gt; ) &lt;stmt&gt;
&lt;if_stmt&gt; -&gt; if ( &lt;logic_expr&gt; ) &lt;stmt&gt; else &lt;stmt&gt;</code></pre></div></div></li></ul></div></section><section id="multiple_definitions_in_one_rule"><h2>Multiple Definitions in One Rule</h2><div class="ulist"><ul><li><p>Multiple definitions can exist in a single rule.</p><div class="listingblock"><div class="content"><pre class="highlight"><code>&lt;if_stmt&gt; -&gt; if ( &lt;logic_expr&gt; ) &lt;stmt&gt;
           | if ( &lt;logic_expr&gt; ) &lt;stmt&gt; else &lt;stmt&gt;</code></pre></div></div></li></ul></div></section><section id="rules_describing_lists"><h2>Rules Describing Lists</h2><div class="ulist"><ul><li><p>If you want to define a rule that allows for a list of variable size, you need to use recursion.</p><div class="listingblock"><div class="content"><pre class="highlight"><code>&lt;ident_list&gt; -&gt; identifier
              | identifier, &lt;ident_list&gt;</code></pre></div></div></li></ul></div></section><section id="start_symbol"><h2>Start Symbol</h2><div class="ulist"><ul><li><p>Special non-terminal that represents a complete program.</p></li><li><p>A program is generated by successfully applying the rules of the grammar to the start symbol.</p><div class="ulist"><ul><li><p>This process is called a <em>derivation</em></p></li></ul></div></li></ul></div></section><section id="example_derivation_grammar_em_g_em"><h2>Example Derivation: Grammar <em>G</em></h2><div class="listingblock"><div class="content"><pre class="highlight"><code>&lt;program&gt;    -&gt; begin &lt;stmt_list&gt; end
&lt;stmt_list&gt;  -&gt; &lt;stmt&gt;
              | &lt;stmt&gt; ; &lt;stmt_list&gt;
&lt;stmt&gt;       -&gt; &lt;var&gt; = &lt;expression&gt;
&lt;var&gt;        -&gt; A|B|C
&lt;expression&gt; -&gt; &lt;var&gt; + &lt;var&gt;
              | &lt;var&gt; â€“ &lt;var&gt;
              | &lt;var&gt;</code></pre></div></div>
<div class="ulist"><ul><li><p>start symbol</p></li><li><p>non-terminals</p></li><li><p>terminals</p></li></ul></div></section><section id="example_derivation_program_em_p_em"><h2>Example Derivation: Program <em>P</em></h2><div class="listingblock"><div class="content"><pre class="highlight"><code>&lt;program&gt; =&gt; begin &lt;stmt_list&gt; end</code></pre></div></div></section><section id="example_derivation_derivation_of_em_p_em"><h2>Example Derivation: Derivation of <em>P</em></h2><div class="listingblock"><div class="content"><pre class="highlight"><code>&lt;program&gt; =&gt; begin &lt;stmt_list&gt; end
          =&gt; begin &lt;stmt&gt;;&lt;stmt_list&gt;end
          =&gt; begin &lt;var&gt; = &lt;expression&gt;;&lt;stmt_list&gt;end
          =&gt; begin A = &lt;expression&gt; ; &lt;stmt_list&gt; end
          =&gt; begin A = &lt;var&gt; + &lt;var&gt; ; &lt;stmt_list&gt; end
          =&gt; begin A = B + &lt;var&gt; ; &lt;stmt_list&gt; end
          =&gt; begin A = B + C ; &lt;stmt_list&gt; end
          =&gt; begin A = B + C ;&lt;stmt&gt;end
          =&gt; begin A = B + C ; &lt;var&gt; = &lt;expression&gt; end
          =&gt; begin A = B + C ; B = &lt;expression&gt; end
          =&gt; begin A = B + C ; B = &lt;var&gt; end
          =&gt; begin A = B + C ; B = C end</code></pre></div></div>
<div class="ulist"><ul><li><p>Sentential forms</p></li><li><p>Replace until no non-terminals.</p></li><li><p>Last sentential form with no non-terminals is the generated sentence.</p></li></ul></div></section><section id="leftmost_vs_rightmost_derivations"><h2>Leftmost vs. Rightmost Derivations</h2><div class="ulist"><ul><li><p>Derivations can perform their substitutions either left-first or right-first</p></li><li><p>Substitute left-most or right-most non-terminal until there are only terminals.</p></li><li><p><em>P</em> used left-most</p></li><li><p>Order has no impact on the generated language.</p></li></ul></div></section><section id="parse_trees"><h2>Parse Trees</h2><div class="ulist"><ul><li><p>Derivations can be represented by a tree</p></li><li><p>internal nodes are non-terminals.</p></li><li><p>leaves are terminals</p></li></ul></div></section><section id="example_parse_tree"><h2>Example parse tree</h2><div class="paragraph"><p>insert diagram</p></div></section><section id="ambiguous_grammars"><h2>Ambiguous Grammars</h2><div class="ulist"><ul><li><p>If a grammar can produce 2 or more parse trees for a give derivation, it is ambiguous</p></li></ul></div></section><section id="example_ambiguous_grammar_grammar_em_ag_em"><h2>Example Ambiguous Grammar: Grammar <em>AG</em></h2><div class="listingblock"><div class="content"><pre class="highlight"><code>&lt;assign&gt; -&gt; &lt;id&gt; = &lt;expr&gt;
&lt;id&gt;     -&gt; A|B|C
&lt;expr&gt;   -&gt; &lt;expr&gt; + &lt;expr&gt;
          | &lt;expr&gt; * &lt;expr&gt;
          | ( &lt;expr&gt; )
          | &lt;id&gt;</code></pre></div></div>
<div class="ulist"><ul><li><p>How is <em>AG</em> different from <em>G</em>?</p></li></ul></div></section><section id="example_ambiguous_grammar_program_em_ap_em_and_derivation"><h2>Example Ambiguous Grammar: Program <em>AP</em> and Derivation</h2><div class="listingblock"><div class="content"><pre class="highlight"><code>&lt;assign&gt; =&gt; &lt;id&gt; = &lt;expr&gt;
         =&gt; A = &lt;expr&gt;
         =&gt; A = &lt;id&gt; * &lt;expr&gt;
         =&gt; A = B * &lt;expr&gt;
         =&gt; A = B * ( &lt;expr&gt; )
         =&gt; A = B * ( &lt;id&gt; + &lt;expr&gt; )
         =&gt; A = B * ( A + &lt;expr&gt; )
         =&gt; A = B * ( A + &lt;id&gt; )
         =&gt; A = B * ( A + C )</code></pre></div></div></section><section id="example_ambiguous_grammar_parse_tree"><h2>Example Ambiguous Grammar: Parse Tree</h2><div class="paragraph"><p>insert diagram</p></div></section><section id="example_ambiguous_grammar_another_parse_tree"><h2>Example Ambiguous Grammar: Another Parse Tree</h2><div class="paragraph"><p>insert diagram</p></div></section><section id="example_ambiguous_grammar_problem"><h2>Example Ambiguous Grammar: Problem?</h2><div class="ulist"><ul><li><p>Why is this an issue?</p><div class="ulist"><ul><li><p>order of operations</p></li></ul></div></li></ul></div></section><section id="example_unambiguous_grammar_grammar_em_ug_em"><h2>Example Unambiguous Grammar: Grammar <em>UG</em></h2><div class="listingblock"><div class="content"><pre class="highlight"><code>&lt;assign&gt; -&gt; &lt;id&gt; = &lt;expr&gt;
&lt;id&gt;     -&gt; A|B|C
&lt;expr&gt;   -&gt; &lt;expr&gt; + &lt;term&gt;
          | &lt;term&gt;
&lt;term&gt;   -&gt; &lt;term&gt; * &lt;factor&gt;
          | &lt;factor&gt;
&lt;factor&gt; -&gt; ( &lt;expr&gt; )
          | &lt;id&gt;</code></pre></div></div></section><section id="example_unambiguous_grammar_program_em_up_em_and_derivation"><h2>Example Unambiguous Grammar: Program <em>UP</em> and Derivation</h2><div class="listingblock"><div class="content"><pre class="highlight"><code>&lt;assign&gt; =&gt; &lt;id&gt; = &lt;expr&gt;
         =&gt; A = &lt;expr&gt;
         =&gt; A = &lt;expr&gt; + &lt;term&gt;
         =&gt; A = &lt;term&gt; + &lt;term&gt;
         =&gt; A = &lt;factor&gt; + &lt;term&gt;
         =&gt; A = &lt;id&gt; + &lt;term&gt;
         =&gt; A = B + &lt;term&gt;
         =&gt; A = B + &lt;term&gt; * &lt;factor&gt;
         =&gt; A = B + &lt;factor&gt; * &lt;factor&gt;
         =&gt; A = B + &lt;id&gt; * &lt;factor&gt;
         =&gt; A = B + C * &lt;factor&gt;
         =&gt; A = B + C * &lt;id&gt;
         =&gt; A = B + C * A</code></pre></div></div></section><section id="example_unambiguous_grammar_parse_tree"><h2>Example Unambiguous Grammar: Parse Tree</h2><div class="paragraph"><p>insert diagram</p></div></section><section id="operator_associativity"><h2>Operator Associativity</h2><div class="ulist"><ul><li><p>When two operators have the same precedence</p></li><li><p>Example <code>5 + 4 - 3</code></p></li></ul></div></section><section id="extended_bnf"><h2>Extended BNF</h2><div class="ulist"><ul><li><p>Helps with readability, but does not change descriptive power</p></li></ul></div></section><section id="ebnf_example_if_else"><h2>EBNF Example: if-else</h2><div class="listingblock"><div class="title">BNF</div><div class="content"><pre class="highlight"><code>&lt;if_stmt&gt; -&gt; if (&lt;expression&gt;) &lt;statement&gt;
           | if (&lt;expression&gt;) &lt;statement&gt; else &lt;statement&gt;</code></pre></div></div>
<div class="listingblock"><div class="title">EBNF</div><div class="content"><pre class="highlight"><code>&lt;if_stmt&gt; -&gt; if (&lt;expression&gt;) &lt;statement&gt; [else &lt;statement&gt;]</code></pre></div></div></section></section>
<section id="static_semantics"><h2>Static Semantics</h2><div class="ulist"><ul><li><p>BNF and EBNF don&#8217;t work for describing all part of a language.</p></li><li><p>Certain typing rules are possible, but it would make the grammar cumbersome.</p><div class="ulist"><ul><li><p>For example integers can be assigned as floats, but not vice-versa.</p></li></ul></div></li><li><p>Certain things like variable declaration and usage cannot be defined.</p><div class="ulist"><ul><li><p>For example, a variable must be declared before it can be used.</p></li></ul></div></li><li><p>These things are the static semantics of a language.</p></li></ul></div></section>
<section><section id="attribute_grammars"><h2>Attribute Grammars</h2><div class="ulist"><ul><li><p>Describes structure and static semantics of a language.</p></li><li><p>Extension of a context-free grammar.</p><div class="ulist"><ul><li><p>Context-free grammar with attributes, attribute computation functions, and predicate functions attached.</p></li></ul></div></li></ul></div></section><section id="attributes"><h2>Attributes</h2><div class="ulist"><ul><li><p>assigned to variables and can have value assigned.</p></li></ul></div></section><section id="attribute_computation_functions"><h2>attribute computation functions</h2><div class="ulist"><ul><li><p>associated with grammar rules</p></li></ul></div></section><section id="predicate_functions"><h2>predicate functions</h2><div class="ulist"><ul><li><p>state the static semantic rules of a language.</p></li><li><p>assocaited with grammar rules</p></li></ul></div></section><section id="example_grammar_em_g_em"><h2>Example Grammar <em>G</em></h2><div class="listingblock"><div class="content"><pre class="highlight"><code>&lt;assign&gt; -&gt; &lt;var&gt; = &lt;expr&gt;
&lt;expr&gt;   -&gt; &lt;var&gt; + &lt;var&gt;
          | &lt;var&gt;
&lt;var&gt;    -&gt; A | B | C</code></pre></div></div></section><section id="example_attribute_grammar_rule_1"><h2>Example Attribute Grammar Rule 1</h2><div class="ulist"><ul><li><p>Syntax rule: <code>&lt;assign&gt; &#8594; &lt;var&gt; = &lt;expr&gt;</code></p></li><li><p>Semantic rule: <code>&lt;expr&gt;.expected_type &#8592; &lt;var&gt;.actual_type</code></p></li></ul></div></section><section id="example_attribute_grammar_rule_2"><h2>Example Attribute Grammar Rule 2</h2><div class="ulist"><ul><li><p>Syntax rule: <code>&lt;expr&gt; &#8594; &lt;var&gt;[2] + &lt;var&gt;[3]</code></p></li><li><p>Semantic rule:</p><div class="listingblock"><div class="content"><pre class="highlight"><code>&lt;expr&gt;.actual_type &lt;-
if (&lt;var&gt;[2].actual_type = int) and
   (&lt;var&gt;[3].actual_type = int)
then int
else real
end if</code></pre></div></div></li><li><p>Predicate: <code>&lt;expr&gt;.actual_type == &lt;expr&gt;.expected_type</code></p></li></ul></div></section><section id="example_attribute_grammar_rule_3"><h2>Example Attribute Grammar Rule 3</h2><div class="ulist"><ul><li><p>Syntax rule: <code>&lt;expr&gt; &#8594; &lt;var&gt;</code></p></li><li><p>Semantic rule: <code>&lt;expr&gt;.actual_type &#8592; &lt;var&gt;.actual_type</code></p></li><li><p>Predicate: <code>&lt;expr&gt;.actual_type == &lt;expr&gt;.expected_type</code></p></li></ul></div></section><section id="example_attribute_grammar_rule_4"><h2>Example Attribute Grammar Rule 4</h2><div class="ulist"><ul><li><p>Syntax rule: <code>&lt;var&gt; &#8594; A | B | C</code></p></li><li><p>Semantic rule: <code>&lt;var&gt;.actual_type &#8592; look-up(&lt;var&gt;.string)</code></p></li></ul></div></section></section></div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.6.0/lib/js/head.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.6.0/js/reveal.js"></script><script>// See https://github.com/hakimel/reveal.js#configuration for a full list of configuration options
Reveal.initialize({
  // Display controls in the bottom right corner
  controls: true,
  // Display a presentation progress bar
  progress: true,
  // Set a per-slide timing for speaker notes, null means none
  defaultTiming: null,
  // Display the page number of the current slide
  slideNumber: false,
  // Push each slide change to the browser history
  history: false,
  // Enable keyboard shortcuts for navigation
  keyboard: true,
  // Enable the slide overview mode
  overview: true,
  // Vertical centering of slides
  center: true,
  // Enables touch navigation on devices with touch input
  touch: true,
  // Loop the presentation
  loop: false,
  // Change the presentation direction to be RTL
  rtl: false,
  // Randomizes the order of slides each time the presentation loads
  shuffle: false,
  // Turns fragments on and off globally
  fragments: true,
  // Flags if the presentation is running in an embedded mode,
  // i.e. contained within a limited portion of the screen
  embedded: false,
  // Flags if we should show a help overlay when the questionmark
  // key is pressed
  help: true,
  // Flags if speaker notes should be visible to all viewers
  showNotes: false,
  // Global override for autolaying embedded media (video/audio/iframe)
  // - null: Media will only autoplay if data-autoplay is present
  // - true: All media will autoplay, regardless of individual setting
  // - false: No media will autoplay, regardless of individual setting
  autoPlayMedia: null,
  // Number of milliseconds between automatically proceeding to the
  // next slide, disabled when set to 0, this value can be overwritten
  // by using a data-autoslide attribute on your slides
  autoSlide: 0,
  // Stop auto-sliding after user input
  autoSlideStoppable: true,
  // Enable slide navigation via mouse wheel
  mouseWheel: false,
  // Hides the address bar on mobile devices
  hideAddressBar: true,
  // Opens links in an iframe preview overlay
  previewLinks: false,
  // Theme (e.g., beige, black, league, night, serif, simple, sky, solarized, white)
  // NOTE setting the theme in the config no longer works in reveal.js 3.x
  //theme: Reveal.getQueryHash().theme || 'black',
  // Transition style (e.g., none, fade, slide, convex, concave, zoom)
  transition: Reveal.getQueryHash().transition || 'slide',
  // Transition speed (e.g., default, fast, slow)
  transitionSpeed: 'default',
  // Transition style for full page slide backgrounds (e.g., none, fade, slide, convex, concave, zoom)
  backgroundTransition: 'fade',
  // Number of slides away from the current that are visible
  viewDistance: 3,
  // Parallax background image (e.g., "'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg'")
  parallaxBackgroundImage: '',
  // Parallax background size in CSS syntax (e.g., "2100px 900px")
  parallaxBackgroundSize: '',

  // The "normal" size of the presentation, aspect ratio will be preserved
  // when the presentation is scaled to fit different resolutions. Can be
  // specified using percentage units.
  width: 960,
  height: 700,

  // Factor of the display size that should remain empty around the content
  margin: 0.1,

  // Bounds for smallest/largest possible scale to apply to content
  minScale: 0.2,
  maxScale: 1.5,

  // Optional libraries used to extend on reveal.js
  dependencies: [
      { src: 'https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.6.0/lib/js/classList.js', condition: function() { return !document.body.classList; } },
      { src: 'https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.6.0/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
      { src: 'https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.6.0/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
      
      { src: 'https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.6.0/plugin/zoom-js/zoom.js', async: true },
      { src: 'https://cdnjs.cloudflare.com/ajax/libs/reveal.js/3.6.0/plugin/notes/notes.js', async: true }
  ]
});</script></body></html>